package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"strings"

	"github.com/google/uuid"
	"github.com/hokita/owl/graph/model"
)

// CreateReview is the resolver for the createReview field.
func (r *mutationResolver) CreateReview(ctx context.Context, input model.CreateReviewInput) (*model.Review, error) {
	reviewUUID, err := uuid.NewUUID()
	if err != nil {
		return nil, err
	}

	if input.Month == nil {
		input.Month = new(int)
	}

	if input.Week == nil {
		input.Week = new(int)
	}

	// Start transaction
	tx, err := r.DB.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}

	// Insert review
	insertReviewQuery := `
		INSERT INTO reviews (id, year, month, week, created_at, updated_at)
		VALUES (?, ?, ?, ?, NOW(), NOW());
	`

	_, err = tx.ExecContext(
		ctx,
		insertReviewQuery,
		reviewUUID.String(),
		input.Year,
		input.Month,
		input.Week,
	)
	if err != nil {
		tx.Rollback()
		return nil, err
	}

	valueStrings := []string{}
	valueArgs := []interface{}{}
	for _, note := range input.Notes {
		noteUUID, err := uuid.NewUUID()
		if err != nil {
			return nil, err
		}

		valueStrings = append(valueStrings, "(?, ?, ?, ?, NOW(), NOW())")
		valueArgs = append(valueArgs, noteUUID.String(), reviewUUID.String(), note.Content, note.Type)
	}

	// Insert notes
	insertNotesQuery := fmt.Sprintf(`
		INSERT INTO notes (id, review_id, content, type, created_at, updated_at)
		VALUES %s;
	`, strings.Join(valueStrings, ","))

	_, err = tx.ExecContext(
		ctx,
		insertNotesQuery,
		valueArgs...,
	)
	if err != nil {
		tx.Rollback()
		return nil, err
	}

	selectQuery := `
		SELECT
			reviews.id,
			reviews.year,
			reviews.month,
			reviews.week,
			reviews.created_at,
			reviews.updated_at,
			notes.id,
			notes.review_id,
			notes.content,
			notes.type,
			notes.created_at,
			notes.updated_at
		FROM
			reviews
		JOIN
			notes
		ON reviews.id = notes.review_id
		WHERE
		    reviews.id = ?
	`
	rows, error := tx.QueryContext(ctx, selectQuery, reviewUUID.String())
	if error != nil {
		return nil, error
	}
	defer rows.Close()

	review := model.Review{}
	notesMap := make(map[string]*model.Note)
	for rows.Next() {
		var (
			reviewID        string
			reviewYear      int
			reviewMonth     int
			reviewWeek      int
			reviewCreatedAt string
			reviewUpdatedAt string
			noteID          sql.NullString
			noteReviewID    sql.NullString
			noteContent     sql.NullString
			noteType        sql.NullString
			noteCreatedAt   sql.NullString
			noteUpdatedAt   sql.NullString
		)

		err := rows.Scan(
			&reviewID,
			&reviewYear,
			&reviewMonth,
			&reviewWeek,
			&reviewCreatedAt,
			&reviewUpdatedAt,
			&noteID,
			&noteReviewID,
			&noteContent,
			&noteType,
			&noteCreatedAt,
			&noteUpdatedAt,
		)
		if err != nil {
			return nil, err
		}

		if review.ID == "" {
			review.ID = reviewID
			review.Year = reviewYear
			review.Month = reviewMonth
			review.Week = reviewWeek
			review.CreatedAt = reviewCreatedAt
			review.UpdatedAt = reviewUpdatedAt
		}
		if noteID.Valid {
			note := &model.Note{
				ID:        noteID.String,
				ReviewID:  noteReviewID.String,
				Content:   noteContent.String,
				Type:      noteType.String,
				CreatedAt: noteCreatedAt.String,
				UpdatedAt: noteUpdatedAt.String,
			}
			notesMap[noteID.String] = note
			review.Notes = append(review.Notes, note)
		}
	}
	if review.ID == "" {
		return nil, nil
	}

	if err := tx.Commit(); err != nil {
		return nil, err
	}

	return &review, nil
}

// CreateNote is the resolver for the createNote field.
func (r *mutationResolver) CreateNote(ctx context.Context, input model.CreateNoteInput) (*model.Note, error) {
	uuid, err := uuid.NewUUID()
	if err != nil {
		return nil, err
	}

	// Start transaction
	tx, err := r.DB.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}

	insertQuery := `
		INSERT INTO notes (id, review_id, content, type, created_at, updated_at)
		VALUES (?, ?, ?, ?, NOW(), NOW());
	`

	_, err = tx.ExecContext(
		ctx,
		insertQuery,
		uuid.String(),
		input.ReviewID,
		input.Content,
		input.Type,
	)
	if err != nil {
		tx.Rollback()
		return nil, err
	}

	var (
		ID        string
		ReviewID  string
		Content   string
		Type      string
		CreatedAt string
		UpdatedAt string
	)
	selectQuery := `
		SELECT
			id,
			review_id,
			content,
			type,
			created_at,
			updated_at
		FROM
			notes
		WHERE
			id = ?
	`
	err = tx.QueryRowContext(
		ctx,
		selectQuery,
		uuid.String(),
	).Scan(
		&ID,
		&ReviewID,
		&Content,
		&Type,
		&CreatedAt,
		&UpdatedAt,
	)
	if err != nil {
		tx.Rollback()
		return nil, err
	}

	if err := tx.Commit(); err != nil {
		return nil, err
	}

	return &model.Note{
		ID:        ID,
		ReviewID:  ReviewID,
		Content:   Content,
		Type:      Type,
		CreatedAt: CreatedAt,
		UpdatedAt: UpdatedAt,
	}, nil
}

// DeleteNote is the resolver for the deleteNote field.
func (r *mutationResolver) DeleteNote(ctx context.Context, id string) (*model.Note, error) {
	// Start transaction
	tx, err := r.DB.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}

	// Select
	var (
		NoteID    string
		ReviewID  string
		Content   string
		Type      string
		CreatedAt string
		UpdatedAt string
	)
	selectQuery := `
		SELECT
			id,
			review_id,
			content,
			type,
			created_at,
			updated_at
		FROM
			notes
		WHERE
			id = ?
	`
	err = tx.QueryRowContext(
		ctx,
		selectQuery,
		id,
	).Scan(
		&NoteID,
		&ReviewID,
		&Content,
		&Type,
		&CreatedAt,
		&UpdatedAt,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, errors.New("Note not found")
		}
		tx.Rollback()
		return nil, err
	}

	// Delete
	deleteQuery := `
		DELETE FROM notes WHERE id = ?;
	`
	_, err = tx.ExecContext(ctx, deleteQuery, id)
	if err != nil {
		tx.Rollback()
		return nil, err
	}

	if err := tx.Commit(); err != nil {
		return nil, err
	}

	return &model.Note{
		ID:        NoteID,
		ReviewID:  ReviewID,
		Content:   Content,
		Type:      Type,
		CreatedAt: CreatedAt,
		UpdatedAt: UpdatedAt,
	}, nil
}

// Review is the resolver for the review field.
func (r *queryResolver) Review(ctx context.Context) (*model.Review, error) {
	query := `
		SELECT
			reviews.id,
			reviews.year,
			reviews.month,
			reviews.week,
			reviews.created_at,
			reviews.updated_at,
			notes.id,
			notes.review_id,
			notes.content,
			notes.type,
			notes.created_at,
			notes.updated_at
		FROM
			reviews
		JOIN
			notes
		ON reviews.id = notes.review_id
	`
	rows, error := r.DB.QueryContext(ctx, query)
	if error != nil {
		return nil, error
	}
	defer rows.Close()

	review := model.Review{}
	notesMap := make(map[string]*model.Note)
	for rows.Next() {
		var (
			reviewID        string
			reviewYear      int
			reviewMonth     int
			reviewWeek      int
			reviewCreatedAt string
			reviewUpdatedAt string
			noteID          sql.NullString
			noteReviewID    sql.NullString
			noteContent     sql.NullString
			noteType        sql.NullString
			noteCreatedAt   sql.NullString
			noteUpdatedAt   sql.NullString
		)

		err := rows.Scan(
			&reviewID,
			&reviewYear,
			&reviewMonth,
			&reviewWeek,
			&reviewCreatedAt,
			&reviewUpdatedAt,
			&noteID,
			&noteReviewID,
			&noteContent,
			&noteType,
			&noteCreatedAt,
			&noteUpdatedAt,
		)
		if err != nil {
			return nil, err
		}
		if review.ID == "" {
			review.ID = reviewID
			review.Year = reviewYear
			review.Month = reviewMonth
			review.Week = reviewWeek
			review.CreatedAt = reviewCreatedAt
			review.UpdatedAt = reviewUpdatedAt
		}
		if noteID.Valid {
			note := &model.Note{
				ID:        noteID.String,
				ReviewID:  noteReviewID.String,
				Content:   noteContent.String,
				Type:      noteType.String,
				CreatedAt: noteCreatedAt.String,
				UpdatedAt: noteUpdatedAt.String,
			}
			notesMap[noteID.String] = note
			review.Notes = append(review.Notes, note)
		}
	}
	return &review, nil
}

// WeekReview is the resolver for the weekReview field.
func (r *queryResolver) WeekReview(ctx context.Context, year int, month int, week int) (*model.Review, error) {
	query := `
		SELECT
			reviews.id,
			reviews.year,
			reviews.month,
			reviews.week,
			reviews.created_at,
			reviews.updated_at,
			notes.id,
			notes.review_id,
			notes.content,
			notes.type,
			notes.created_at,
			notes.updated_at
		FROM
			reviews
		LEFT JOIN
			notes
		ON reviews.id = notes.review_id
		WHERE
		    reviews.year = ? AND
			reviews.month = ? AND
			reviews.week = ?
	`
	rows, error := r.DB.QueryContext(ctx, query, year, month, week)
	if error != nil {
		return nil, error
	}
	defer rows.Close()

	review := model.Review{}
	notesMap := make(map[string]*model.Note)
	for rows.Next() {
		var (
			reviewID        string
			reviewYear      int
			reviewMonth     int
			reviewWeek      int
			reviewCreatedAt string
			reviewUpdatedAt string
			noteID          sql.NullString
			noteReviewID    sql.NullString
			noteContent     sql.NullString
			noteType        sql.NullString
			noteCreatedAt   sql.NullString
			noteUpdatedAt   sql.NullString
		)

		err := rows.Scan(
			&reviewID,
			&reviewYear,
			&reviewMonth,
			&reviewWeek,
			&reviewCreatedAt,
			&reviewUpdatedAt,
			&noteID,
			&noteReviewID,
			&noteContent,
			&noteType,
			&noteCreatedAt,
			&noteUpdatedAt,
		)
		if err != nil {
			return nil, err
		}
		if review.ID == "" {
			review.ID = reviewID
			review.Year = reviewYear
			review.Month = reviewMonth
			review.Week = reviewWeek
			review.CreatedAt = reviewCreatedAt
			review.UpdatedAt = reviewUpdatedAt
		}
		if noteID.Valid {
			note := &model.Note{
				ID:        noteID.String,
				ReviewID:  noteReviewID.String,
				Content:   noteContent.String,
				Type:      noteType.String,
				CreatedAt: noteCreatedAt.String,
				UpdatedAt: noteUpdatedAt.String,
			}
			notesMap[noteID.String] = note
			review.Notes = append(review.Notes, note)
		}
	}
	if review.ID == "" {
		return nil, nil
	}
	return &review, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
