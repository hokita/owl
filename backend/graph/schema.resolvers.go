package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"database/sql"

	"github.com/hokita/owl/graph/model"
)

// Review is the resolver for the review field.
func (r *queryResolver) Review(ctx context.Context) (*model.Review, error) {
	query := `
		SELECT
			reviews.id,
			reviews.type,
			reviews.year,
			reviews.month,
			reviews.week,
			reviews.created_at,
			reviews.updated_at,
			notes.id,
			notes.content,
			notes.type,
			notes.created_at,
			notes.updated_at
		FROM
			reviews
		JOIN
			notes
		ON reviews.id = notes.review_id
	`
	rows, error := r.DB.Query(query)
	if error != nil {
		return nil, error
	}
	defer rows.Close()

	review := model.Review{}
	notesMap := make(map[string]*model.Note)
	for rows.Next() {
		var (
			reviewID        string
			reviewType      string
			reviewYear      int
			reviewMonth     *int
			reviewWeek      *int
			reviewCreatedAt string
			reviewUpdatedAt string
			noteID          sql.NullString
			noteContent     sql.NullString
			noteType        sql.NullString
			noteCreatedAt   sql.NullString
			noteUpdatedAt   sql.NullString
		)

		err := rows.Scan(
			&reviewID,
			&reviewType,
			&reviewYear,
			&reviewMonth,
			&reviewWeek,
			&reviewCreatedAt,
			&reviewUpdatedAt,
			&noteID,
			&noteContent,
			&noteType,
			&noteCreatedAt,
			&noteUpdatedAt,
		)
		if err != nil {
			return nil, err
		}
		if review.ID == "" {
			review.ID = reviewID
			review.Type = reviewType
			review.Year = reviewYear
			review.Month = reviewMonth
			review.Week = reviewWeek
			review.CreatedAt = reviewCreatedAt
			review.UpdatedAt = reviewUpdatedAt
		}
		if noteID.Valid {
			note := &model.Note{
				ID:        noteID.String,
				Content:   noteContent.String,
				Type:      noteType.String,
				CreatedAt: noteCreatedAt.String,
				UpdatedAt: noteUpdatedAt.String,
			}
			notesMap[noteID.String] = note
			review.Notes = append(review.Notes, note)
		}
	}
	return &review, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
